<!DOCTYPE html>
<html lang="en">

<!-- ============================================================================
     PORTFOLIO PAGE - Audio Design Studios
     Full audio playlists with custom players
     ============================================================================ -->

<head>
  <!-- Meta Information -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Audio Design Studios – Karter G. Brown</title>
  
  <!-- Stylesheets -->
  <link rel="stylesheet" href="styles.css?v=1765390693" />
</head>

<body>
  <!-- ========================================================================
       SITE HEADER - Navigation
       ======================================================================== -->
  <header class="site-header">
    <a href="matrix.html" class="logo" style="text-decoration: none;">Audio Design Studios</a>
    <nav class="nav">
      <a href="index.html">Home</a>
      <a href="portfolio.html">Portfolio</a>
      <a href="about.html">About</a>
      <a href="music.html">Music</a>
    </nav>
  </header>

  <!-- ========================================================================
       MAIN CONTENT
       ======================================================================== -->
  <main>
    
    <!-- ======================================================================
         SECTION 1: Hero Image Banner
         ====================================================================== -->
    <section class="env-image env-portfolio"></section>

    <!-- ======================================================================
         SECTION 2: Full-Width Playlists (2 Custom Audio Players)
         Left: Daughter of the Plains | Right: All Works
         ====================================================================== -->
    <section class="playlists-section">
      <div class="playlists-container">
        
        <!-- Left Playlist: Daughter of the Plains -->
        <div class="playlist-card">
          <!-- Album Art & Title -->
          <div class="playlist-card-header">
            <div class="playlist-album-art">
              <picture>
                <source media="(min-width:1200px)" srcset="daughteroftheplains/daughteroftheplains2000.webp">
                <source media="(min-width:720px)" srcset="daughteroftheplains/daughteroftheplains1400.webp">
                <img src="daughteroftheplains/daughteroftheplains800.webp" alt="Daughter of the Plains">
              </picture>
            </div>
            <h3>Daughter of the Plains</h3>
          </div>
          
          <!-- Progress Bar -->
          <div id="mainWave" class="main-player-progress" aria-hidden="true"></div>
          
          <!-- Now Playing Display -->
          <div id="dotpNowPlaying" class="now-playing-info">No track playing</div>
          
          <!-- Transport Controls -->
          <div class="playlist-player-controls">
            <button id="prevBtn" class="control-btn" aria-label="Back to beginning">⏮</button>
            <button id="playPauseBtn" class="control-btn control-btn-play" aria-label="Play/Pause">▶</button>
            <button id="nextBtn" class="control-btn" aria-label="Next track">⏭</button>
          </div>
          
          <!-- Track List -->
          <div class="playlist-content" id="dotpPlaylist">
            <!-- Tracks injected via JavaScript -->
          </div>
        </div>

        <!-- Right Playlist: All Works -->
        <div class="playlist-card">
          <!-- Album Art & Title -->
          <div class="playlist-card-header">
            <div class="playlist-album-art">
              <img src="Photos/headshot.webp" alt="All Works">
            </div>
            <h3>Sample Music</h3>
          </div>
          
          <!-- Progress Bar -->
          <div id="allMainWave" class="main-player-progress" aria-hidden="true"></div>
          
          <!-- Now Playing Display -->
          <div id="allWorksNowPlaying" class="now-playing-info">No track playing</div>
          
          <!-- Transport Controls -->
          <div class="playlist-player-controls">
            <button id="allPrevBtn" class="control-btn" aria-label="Back to beginning">⏮</button>
            <button id="allPlayPauseBtn" class="control-btn control-btn-play" aria-label="Play/Pause">▶</button>
            <button id="allNextBtn" class="control-btn" aria-label="Next track">⏭</button>
          </div>
          
          <!-- Track List (Scrollable) -->
          <div class="playlist-scroll" id="allWorksPlaylist">
            <!-- Tracks injected via JavaScript -->
          </div>
        </div>
        
      </div>
    </section>

    <!-- ======================================================================
         SECTION 3: Before & After Playlist (10 Tracks)
         ====================================================================== -->
    <section class="section before-after-playlist-section">
      <h2>Before & After Mixing and Mastering</h2>
      <p class="centered-text">Compare raw recordings with final mixed and mastered versions. Use the toggle to switch between before and after.</p>
      
      <div class="playlist-card">
        <!-- Global Toggle Section -->
        <div class="ba-global-toggle-section">
          <span class="ba-toggle-label ba-toggle-before">Before</span>
          <label class="ba-toggle-switch">
            <input type="checkbox" id="baGlobalToggle">
            <span class="ba-toggle-slider"></span>
          </label>
          <span class="ba-toggle-label ba-toggle-after">After</span>
        </div>

        <!-- Progress Bar -->
        <div id="baWave" class="main-player-progress" aria-hidden="true"></div>

        <!-- Now Playing Display -->
        <div id="baNowPlaying" class="now-playing-info">No track playing</div>

        <!-- Transport Controls -->
        <div class="playlist-player-controls">
          <button id="baPrevBtn" class="control-btn" aria-label="Back to beginning">⏮</button>
          <button id="baPlayPauseBtn" class="control-btn control-btn-play" aria-label="Play/Pause">▶</button>
          <button id="baNextBtn" class="control-btn" aria-label="Next track">⏭</button>
        </div>

        <!-- Track List -->
        <div class="playlist-content" id="baPlaylistTracks">
          <!-- Track rows will be injected via JavaScript -->
        </div>
      </div>
    </section>

    <!-- ======================================================================
         SECTION 4: Red Matrix Animation (Musical Notes)
         ====================================================================== -->
    <a href="about.html" class="matrix-link">
      <section class="matrix-section">
        <div class="matrix-terminal" id="matrixTerminalRed"></div>
      </section>
    </a>
  </main>

  <!-- ========================================================================
       SITE FOOTER - Contact Information
       ======================================================================== -->
  <footer class="site-footer">
    <div class="footer-content">
      <h2>Contact</h2>
      <p>Email: <a href="mailto:music@kartergbrown.com">music@kartergbrown.com</a></p>
      <p class="footer-copy">© <span id="year"></span> Audio Design Studios. All rights reserved.</p>
    </div>
  </footer>

  <!-- ========================================================================
       SCRIPTS
       ======================================================================== -->
  
  <!-- Content Configuration & Dynamic Loader (Edit text/styles here) -->
  <script src="content.js?v=1765390693"></script>
  
  <!-- ========================================================================
       Audio Player System (Main Playlists Only)
       ======================================================================== -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let activeDrag = null; // Shared drag state for all players

      // ======================================================================
      // MAIN PLAYLIST PLAYERS (Daughter of the Plains & All Works)
      // ======================================================================
      
      // Audio instances
      const mainAudio = new Audio();
      const allMainAudio = new Audio();

      // Control buttons
      const playPauseBtn = document.getElementById('playPauseBtn');
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      const allPlayPauseBtn = document.getElementById('allPlayPauseBtn');
      const allPrevBtn = document.getElementById('allPrevBtn');
      const allNextBtn = document.getElementById('allNextBtn');

      // Playlist container lookup
      const playlistButtonLookup = {
        dotp: 'dotpPlaylist',
        allWorks: 'allWorksPlaylist'
      };

      // Get all track buttons for a playlist
      const getTrackButtons = (key) => {
        const containerId = playlistButtonLookup[key];
        if (!containerId) return [];
        const container = document.getElementById(containerId);
        return container ? Array.from(container.querySelectorAll('.track-item-play-btn')) : [];
      };

      // Player context objects
      const players = {
        dotp: {
          audio: mainAudio,
          controls: { playPauseBtn, prevBtn, nextBtn },
          current: null,
          key: 'dotp',
          progressWrap: document.getElementById('mainWave'),
          nowPlayingEl: document.getElementById('dotpNowPlaying'),
          scrubber: null
        },
        allWorks: {
          audio: allMainAudio,
          controls: { playPauseBtn: allPlayPauseBtn, prevBtn: allPrevBtn, nextBtn: allNextBtn },
          current: null,
          key: 'allWorks',
          progressWrap: document.getElementById('allMainWave'),
          nowPlayingEl: document.getElementById('allWorksNowPlaying'),
          scrubber: null
        }
      };

      // Create progress fills and scrubbers for main players
      Object.values(players).forEach(ctx => {
        const progressFill = document.createElement('div');
        progressFill.className = 'main-player-progress-fill';
        progressFill.style.width = '0%';
        ctx.progressWrap.appendChild(progressFill);
        ctx.progressFill = progressFill;
        
        const scrubber = document.createElement('div');
        scrubber.className = 'main-player-scrubber';
        ctx.progressWrap.appendChild(scrubber);
        ctx.scrubber = scrubber;
      });

      function loadAndPlayInPlayer(playerKey, track, btn, itemProgressEl, timeEl) {
        const ctx = players[playerKey];
        if (!ctx) return;
        const url = typeof track === 'string' ? track : track.url || track;
        if (!url) return;

        if (ctx.current && ctx.current.btn === btn) {
          if (ctx.audio.paused) {
            ctx.audio.play();
          } else {
            ctx.audio.pause();
          }
          return;
        }

        if (ctx.current?.btn) ctx.current.btn.textContent = '▶';
        const itemScrubber = itemProgressEl?.parentElement?.querySelector('.track-item-scrubber');
        ctx.current = { btn, itemProgressEl, itemScrubber, timeEl, track };
        btn.textContent = '…';

        // Update now playing info
        if (ctx.nowPlayingEl) {
          const trackTitle = track.title || 'Unknown Track';
          ctx.nowPlayingEl.textContent = trackTitle;
        }

        ctx.audio.src = url;
        ctx.audio.load();
        ctx.audio.play().catch(e => console.warn('play failed', e));
      }

      function attachAudioEvents(playerKey) {
        const ctx = players[playerKey];
        if (!ctx) return;
        const { audio, controls } = ctx;

        audio.addEventListener('timeupdate', () => {
          if (!ctx.current) return;
          const cur = audio.currentTime || 0;
          const dur = audio.duration || 0;
          const pct = dur ? (cur / dur) : 0;
          if (ctx.current.itemProgressEl) ctx.current.itemProgressEl.style.width = `${pct * 100}%`;
          if (ctx.current.itemScrubber) ctx.current.itemScrubber.style.left = `${pct * 100}%`;
          if (ctx.current.timeEl) ctx.current.timeEl.textContent = `${formatTime(cur)} / ${formatTime(dur)}`;
          
          // Update main player progress fill and scrubber position
          if (ctx.progressFill) {
            ctx.progressFill.style.width = `${pct * 100}%`;
          }
          if (ctx.scrubber) {
            ctx.scrubber.style.left = `${pct * 100}%`;
          }
          
          // Update now playing time
          if (ctx.nowPlayingEl && ctx.current.track) {
            const trackTitle = ctx.current.track.title || 'Unknown Track';
            ctx.nowPlayingEl.textContent = `${trackTitle} • ${formatTime(cur)} / ${formatTime(dur)}`;
          }
        });

        audio.addEventListener('play', () => {
          if (controls.playPauseBtn) controls.playPauseBtn.textContent = '⏸';
          if (ctx.current?.btn) ctx.current.btn.textContent = '⏸';
        });

        audio.addEventListener('pause', () => {
          if (controls.playPauseBtn) controls.playPauseBtn.textContent = '▶';
          if (ctx.current?.btn) ctx.current.btn.textContent = '▶';
        });

        audio.addEventListener('ended', () => {
          if (controls.playPauseBtn) controls.playPauseBtn.textContent = '▶';
          if (ctx.current?.btn) ctx.current.btn.textContent = '▶';
          if (ctx.current?.itemProgressEl) ctx.current.itemProgressEl.style.width = '0%';
          if (ctx.current?.itemScrubber) ctx.current.itemScrubber.style.left = '0%';
          if (ctx.progressFill) ctx.progressFill.style.width = '0%';
          if (ctx.scrubber) ctx.scrubber.style.left = '0%';
        });

        audio.addEventListener('loadedmetadata', () => {
          if (ctx.current?.btn) ctx.current.btn.textContent = '⏸';
        });

        // Drag and click main player progress to seek
        const updateMainSeek = (e) => {
          if (!audio.src || !audio.duration) return;
          const rect = ctx.progressWrap.getBoundingClientRect();
          const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
          audio.currentTime = pct * audio.duration;
        };

        ctx.progressWrap.addEventListener('mousedown', (e) => {
          e.preventDefault();
          activeDrag = { element: ctx.progressWrap, update: updateMainSeek };
          updateMainSeek(e);
          ctx.progressWrap.style.cursor = 'grabbing';
        });

        ctx.progressWrap.addEventListener('click', (e) => {
          if (!activeDrag) updateMainSeek(e);
        });
      }

      // Attach events for both playlists
      attachAudioEvents('dotp');
      attachAudioEvents('allWorks');

      // ======================================================================
      // PLAYLIST DATA
      // ======================================================================
      const daughterOfPlainsData = [
        { title: 'Daughter of the Plains (Score)', url: 'daughteroftheplains/01daughteroftheplainsscore.mp3' },
        { title: 'BIG', url: 'daughteroftheplains/02big.mp3' },
        { title: 'Alisons Theme', url: 'daughteroftheplains/03alisonstheme.mp3' },
        { title: 'Like A Child', url: 'daughteroftheplains/04likeachild.mp3' },
        { title: 'Daughter of the Plains (Motif)', url: 'daughteroftheplains/05daughteroftheplainsmotif.mp3' }
      ];

      const allWorksData = [
        { title: 'Hopeful', url: 'allworks/hopeful.mp3' },
        { title: 'Those Who Save Lives', url: 'allworks/thosewhosavelives.mp3' },
        { title: 'Neon Wasteland', url: 'allworks/NeonWasteland_FullMix.mp3' },
        { title: 'Interstellar Worlds Align', url: 'allworks/Interstellar Worlds Align.mp3' },
        { title: 'Slave to Spiritual Death', url: 'allworks/slavetospiritualdeath.mp3' },
        { title: 'One Step Closer', url: 'allworks/onestepcloser.mp3' },
        { title: 'Reggae Demo', url: 'allworks/reggaedemo.mp3' },
        { title: 'Buried Trials', url: 'allworks/BuriedTrials_FullMix.mp3' },
        { title: 'Chime and Glimmer', url: 'allworks/chimeandglimmer.mp3' },
        { title: 'Cavalry March', url: 'allworks/cavalrymarch.mp3' },
      ];

      // ======================================================================
      // PLAYLIST ITEM CREATION
      // ======================================================================
      
      // Format time (seconds to MM:SS)
      function formatTime(sec) {
        const safeSec = Math.max(0, Math.floor(sec || 0));
        const m = Math.floor(safeSec / 60);
        const s = safeSec % 60;
        return `${m}:${s.toString().padStart(2, '0')}`;
      }

      function createPlaylistItem(track, index, playlistKey) {
        const item = document.createElement('div');
        item.className = 'track-item';

        const info = document.createElement('div');
        info.className = 'track-item-info';

        const num = document.createElement('div');
        num.className = 'track-item-number';
        num.textContent = `${index + 1}`;

        const title = document.createElement('div');
        title.className = 'track-item-title';
        title.textContent = track.title;

        const progressWrap = document.createElement('div');
        progressWrap.className = 'track-item-progress-wrap';
        const progressFill = document.createElement('div');
        progressFill.className = 'track-item-progress-fill';
        progressFill.style.width = '0%';
        const scrubber = document.createElement('div');
        scrubber.className = 'track-item-scrubber';
        progressWrap.appendChild(progressFill);
        progressWrap.appendChild(scrubber);

        const timeEl = document.createElement('div');
        timeEl.className = 'track-item-time';
        timeEl.textContent = '0:00 / 0:00';

        info.appendChild(num);
        info.appendChild(title);
        info.appendChild(progressWrap);

        const btn = document.createElement('button');
        btn.className = 'track-item-play-btn';
        btn.setAttribute('aria-label', `Play ${track.title}`);
        btn.textContent = '▶';

        // Make entire track item clickable to play
        item.addEventListener('click', (e) => {
          // Don't trigger if clicking progress bar or button directly
          if (!e.target.closest('.track-item-progress-wrap') && !e.target.closest('.track-item-play-btn')) {
            loadAndPlayInPlayer(playlistKey, track, btn, progressFill, timeEl);
          }
        });
        item.style.cursor = 'pointer';

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          loadAndPlayInPlayer(playlistKey, track, btn, progressFill, timeEl);
        });

        const updateProgress = (e) => {
          const rect = progressWrap.getBoundingClientRect();
          const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
          const targetAudio = players[playlistKey]?.audio;
          if (targetAudio && targetAudio.duration) {
            targetAudio.currentTime = pct * targetAudio.duration;
          }
        };

        progressWrap.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          e.preventDefault();
          activeDrag = { element: progressWrap, update: updateProgress };
          updateProgress(e);
          progressWrap.style.cursor = 'grabbing';
        });

        progressWrap.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!activeDrag) updateProgress(e);
        });

        item.appendChild(info);
        item.appendChild(timeEl);
        item.appendChild(btn);

        return item;
      }

      // Populate playlists
      const dotpEl = document.getElementById('dotpPlaylist');
      const allWorksEl = document.getElementById('allWorksPlaylist');

      daughterOfPlainsData.forEach((track, idx) => {
        dotpEl.appendChild(createPlaylistItem(track, idx, 'dotp'));
      });

      allWorksData.forEach((track, idx) => {
        allWorksEl.appendChild(createPlaylistItem(track, idx, 'allWorks'));
      });

      // ======================================================================
      // TRANSPORT CONTROLS (Play/Pause, Prev, Next)
      // ======================================================================
      function attachTransportHandlers(playerKey) {
        const ctx = players[playerKey];
        if (!ctx) return;
        const { controls, audio } = ctx;

        const handlePlayPause = () => {
          if (!ctx.current) {
            const firstBtn = getTrackButtons(playerKey)[0];
            if (firstBtn) {
              firstBtn.click();
              return;
            }
          }
          if (audio.paused) {
            audio.play();
          } else {
            audio.pause();
          }
        };

        const handlePrev = () => {
          if (audio.currentTime > 3) {
            audio.currentTime = 0;
            return;
          }
          const buttons = getTrackButtons(playerKey);
          const currentIdx = buttons.findIndex((btn) => btn === ctx.current?.btn);
          if (currentIdx > 0) buttons[currentIdx - 1].click();
        };

        const handleNext = () => {
          const buttons = getTrackButtons(playerKey);
          const currentIdx = buttons.findIndex((btn) => btn === ctx.current?.btn);
          if (currentIdx >= 0 && currentIdx < buttons.length - 1) buttons[currentIdx + 1].click();
        };

        if (controls.playPauseBtn) controls.playPauseBtn.addEventListener('click', handlePlayPause);
        if (controls.prevBtn) controls.prevBtn.addEventListener('click', handlePrev);
        if (controls.nextBtn) controls.nextBtn.addEventListener('click', handleNext);
      }

      // Attach transport controls for both playlists
      attachTransportHandlers('dotp');
      attachTransportHandlers('allWorks');

      // ======================================================================
      // Before & After Playlist with Global Player
      // ======================================================================
      const baTracks = [
        { id: 1, title: 'Near Wild Heaven - R.E.M (Cover)', before: 'highlights/B_NearWildHeaven_12072025.mp3', after: 'highlights/A_NearWildHeaven_12072025.mp3' },
        { id: 2, title: 'Hysteria - Muse (Drum Cover)', before: 'highlights/B_hysteriadrum.mp3', after: 'highlights/A_hysteriadrum.mp3' },
        { id: 3, title: 'Were In this Together - Nine Inch Nails (Drum Cover)', before: 'highlights/B_wereinthistogetherdrum.mp3', after: 'highlights/A_wereinthistogetherdrum.mp3' },
      ];

      // Two audio elements: one for before versions, one for after versions
      const baBeforeAudio = new Audio();
      const baAfterAudio = new Audio();
      const baPlaylistContainer = document.getElementById('baPlaylistTracks');
      const baGlobalToggle = document.getElementById('baGlobalToggle');
      const baPlayPauseBtn = document.getElementById('baPlayPauseBtn');
      const baPrevBtn = document.getElementById('baPrevBtn');
      const baNextBtn = document.getElementById('baNextBtn');
      const baNowPlaying = document.getElementById('baNowPlaying');
      const baProgressWrap = document.getElementById('baWave');

      let baCurrentTrackIndex = -1;
      let isPlaying = false;
      
      // Initialize: Before is audible, After is muted
      baBeforeAudio.muted = false;
      baAfterAudio.muted = true;

      // Utility: Wait for audio to be ready to play
      function waitForReady(audio) {
        return new Promise(resolve => {
          if (audio.readyState >= 3) {
            resolve();
          } else {
            audio.addEventListener('canplaythrough', resolve, { once: true });
          }
        });
      }

      // Create progress fill and scrubber
      const baProgressFill = document.createElement('div');
      baProgressFill.className = 'main-player-progress-fill';
      baProgressFill.style.width = '0%';
      baProgressWrap.appendChild(baProgressFill);

      const baScrubber = document.createElement('div');
      baScrubber.className = 'main-player-scrubber';
      baProgressWrap.appendChild(baScrubber);

      // Build track list
      baTracks.forEach((track, index) => {
        const trackRow = document.createElement('div');
        trackRow.className = 'track-item';
        trackRow.dataset.trackIndex = index;
        trackRow.style.cursor = 'pointer';

        const info = document.createElement('div');
        info.className = 'track-item-info';

        const num = document.createElement('span');
        num.className = 'track-item-number';
        num.textContent = track.id;

        const title = document.createElement('span');
        title.className = 'track-item-title';
        title.textContent = track.title;

        const progressWrap = document.createElement('div');
        progressWrap.className = 'track-item-progress-wrap';

        const progressFill = document.createElement('div');
        progressFill.className = 'track-item-progress-fill';
        progressFill.style.width = '0%';
        progressWrap.appendChild(progressFill);

        const itemScrubber = document.createElement('div');
        itemScrubber.className = 'track-item-scrubber';
        progressWrap.appendChild(itemScrubber);

        const timeEl = document.createElement('div');
        timeEl.className = 'track-item-time';
        timeEl.textContent = '0:00 / 0:00';

        info.appendChild(num);
        info.appendChild(title);
        info.appendChild(progressWrap);

        const btn = document.createElement('button');
        btn.className = 'track-item-play-btn';
        btn.setAttribute('aria-label', `Play ${track.title}`);
        btn.textContent = '▶';

        // Store references
        track._uiRefs = { btn, progressFill, itemScrubber, timeEl };

        // Make entire track item clickable to play
        trackRow.addEventListener('click', (e) => {
          if (!e.target.closest('.track-item-progress-wrap') && !e.target.closest('.track-item-play-btn')) {
            loadBATrack(index);
          }
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          loadBATrack(index);
        });

        // Progress bar interaction
        const updateProgress = (e) => {
          const rect = progressWrap.getBoundingClientRect();
          const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
          if (baBeforeAudio.duration) {
            const newTime = pct * baBeforeAudio.duration;
            baBeforeAudio.currentTime = newTime;
            baAfterAudio.currentTime = newTime;
          }
        };

        progressWrap.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          e.preventDefault();
          activeDrag = { element: progressWrap, update: updateProgress };
          updateProgress(e);
          progressWrap.style.cursor = 'grabbing';
        });

        progressWrap.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!activeDrag) updateProgress(e);
        });

        trackRow.appendChild(info);
        trackRow.appendChild(timeEl);
        trackRow.appendChild(btn);
        baPlaylistContainer.appendChild(trackRow);
      });

      // Load and play a track
      function loadBATrack(index) {
        const track = baTracks[index];
        
        if (baCurrentTrackIndex === index) {
          // Toggle play/pause for current track
          if (isPlaying) {
            baBeforeAudio.pause();
            baAfterAudio.pause();
            isPlaying = false;
          } else {
            Promise.all([
              baBeforeAudio.play(),
              baAfterAudio.play()
            ]).catch(e => console.warn('play failed', e));
            isPlaying = true;
          }
          return;
        }

        // Reset previous track button
        if (baCurrentTrackIndex >= 0 && baTracks[baCurrentTrackIndex]._uiRefs) {
          baTracks[baCurrentTrackIndex]._uiRefs.btn.textContent = '▶';
        }

        baCurrentTrackIndex = index;

        // Update UI
        document.querySelectorAll('#baPlaylistTracks .track-item').forEach((item, i) => {
          item.classList.toggle('active', i === index);
        });

        if (track._uiRefs) {
          track._uiRefs.btn.textContent = '…';
        }

        const beforeOrAfter = baBeforeAudio.muted ? 'After' : 'Before';
        baNowPlaying.textContent = `Now Playing: ${track.title} (${beforeOrAfter})`;

        // Load both versions
        baBeforeAudio.src = track.before;
        baAfterAudio.src = track.after;
        
        // Wait for both to be ready, then play simultaneously
        Promise.all([
          waitForReady(baBeforeAudio),
          waitForReady(baAfterAudio)
        ]).then(() => {
          return Promise.all([
            baBeforeAudio.play(),
            baAfterAudio.play()
          ]);
        }).then(() => {
          isPlaying = true;
          if (track._uiRefs) {
            track._uiRefs.btn.textContent = '⏸';
          }
        }).catch(e => console.warn('play failed', e));
      }

      // Progress bar update - use beforeAudio for tracking
      baBeforeAudio.addEventListener('timeupdate', () => {
        const cur = baBeforeAudio.currentTime || 0;
        const dur = baBeforeAudio.duration || 0;
        const pct = dur ? (cur / dur) : 0;
        const percent = pct * 100;
        
        baProgressFill.style.width = percent + '%';
        baScrubber.style.left = percent + '%';

        // Update current track item progress
        if (baCurrentTrackIndex >= 0) {
          const track = baTracks[baCurrentTrackIndex];
          if (track._uiRefs) {
            track._uiRefs.progressFill.style.width = percent + '%';
            track._uiRefs.itemScrubber.style.left = percent + '%';
            track._uiRefs.timeEl.textContent = `${formatTime(cur)} / ${formatTime(dur)}`;
          }
          
          const beforeOrAfter = baBeforeAudio.muted ? 'After' : 'Before';
          baNowPlaying.textContent = `${track.title} (${beforeOrAfter}) • ${formatTime(cur)} / ${formatTime(dur)}`;
        }
      });

      // Progress bar click to seek - seek both tracks
      baProgressWrap.addEventListener('click', (e) => {
        if (baBeforeAudio.duration) {
          const rect = baProgressWrap.getBoundingClientRect();
          const percent = (e.clientX - rect.left) / rect.width;
          const newTime = percent * baBeforeAudio.duration;
          baBeforeAudio.currentTime = newTime;
          baAfterAudio.currentTime = newTime;
        }
      });

      // Global toggle between before/after - just swap mute state
      baGlobalToggle.addEventListener('change', (e) => {
        // Update label styling
        const beforeLabel = document.querySelector('.ba-toggle-before');
        const afterLabel = document.querySelector('.ba-toggle-after');
        
        if (e.target.checked) {
          // After is active (unmuted)
          baBeforeAudio.muted = true;
          baAfterAudio.muted = false;
          
          beforeLabel.style.opacity = '0.6';
          beforeLabel.style.fontWeight = '500';
          afterLabel.style.opacity = '1';
          afterLabel.style.fontWeight = '600';
        } else {
          // Before is active (unmuted)
          baBeforeAudio.muted = false;
          baAfterAudio.muted = true;
          
          beforeLabel.style.opacity = '1';
          beforeLabel.style.fontWeight = '600';
          afterLabel.style.opacity = '0.6';
          afterLabel.style.fontWeight = '500';
        }

        // Update now playing text
        if (baCurrentTrackIndex >= 0) {
          const track = baTracks[baCurrentTrackIndex];
          const beforeOrAfter = baBeforeAudio.muted ? 'After' : 'Before';
          baNowPlaying.textContent = `Now Playing: ${track.title} (${beforeOrAfter})`;
        }
      });

      // Play/Pause button
      baPlayPauseBtn.addEventListener('click', () => {
        if (baCurrentTrackIndex === -1) {
          loadBATrack(0);
        } else if (isPlaying) {
          baBeforeAudio.pause();
          baAfterAudio.pause();
          isPlaying = false;
        } else {
          Promise.all([
            baBeforeAudio.play(),
            baAfterAudio.play()
          ]).then(() => {
            isPlaying = true;
          }).catch(e => console.warn('play failed', e));
        }
      });

      // Audio event listeners
      baBeforeAudio.addEventListener('play', () => {
        baPlayPauseBtn.textContent = '⏸';
        if (baCurrentTrackIndex >= 0 && baTracks[baCurrentTrackIndex]._uiRefs) {
          baTracks[baCurrentTrackIndex]._uiRefs.btn.textContent = '⏸';
        }
      });

      baBeforeAudio.addEventListener('pause', () => {
        baPlayPauseBtn.textContent = '▶';
        if (baCurrentTrackIndex >= 0 && baTracks[baCurrentTrackIndex]._uiRefs) {
          baTracks[baCurrentTrackIndex]._uiRefs.btn.textContent = '▶';
        }
      });

      baBeforeAudio.addEventListener('ended', () => {
        baPlayPauseBtn.textContent = '▶';
        isPlaying = false;
        if (baCurrentTrackIndex >= 0 && baTracks[baCurrentTrackIndex]._uiRefs) {
          baTracks[baCurrentTrackIndex]._uiRefs.btn.textContent = '▶';
          baTracks[baCurrentTrackIndex]._uiRefs.progressFill.style.width = '0%';
          baTracks[baCurrentTrackIndex]._uiRefs.itemScrubber.style.left = '0%';
        }
        baProgressFill.style.width = '0%';
        baScrubber.style.left = '0%';
        
        // Auto-play next track
        if (baCurrentTrackIndex < baTracks.length - 1) {
          loadBATrack(baCurrentTrackIndex + 1);
        }
      });

      baBeforeAudio.addEventListener('loadedmetadata', () => {
        if (baCurrentTrackIndex >= 0 && baTracks[baCurrentTrackIndex]._uiRefs) {
          baTracks[baCurrentTrackIndex]._uiRefs.btn.textContent = '⏸';
        }
      });

      // Previous button
      baPrevBtn.addEventListener('click', () => {
        if (baBeforeAudio.currentTime > 3) {
          baBeforeAudio.currentTime = 0;
          baAfterAudio.currentTime = 0;
        } else if (baCurrentTrackIndex > 0) {
          loadBATrack(baCurrentTrackIndex - 1);
        }
      });

      // Next button
      baNextBtn.addEventListener('click', () => {
        if (baCurrentTrackIndex < baTracks.length - 1) {
          loadBATrack(baCurrentTrackIndex + 1);
        }
      });

    });
  </script>

  <!-- ========================================================================
       Red Matrix Terminal Effect (Musical Notes)
       ======================================================================== -->
  <script>
    const terminalRed = document.getElementById('matrixTerminalRed');
    const canvasRed = document.createElement('canvas');
    const ctxRed = canvasRed.getContext('2d');
    terminalRed.appendChild(canvasRed);
    
    const charsRed = '♩♪♫♬♭♮♯';
    let columnsRed, dropsRed, xPositionsRed;
    
    function resizeRed() {
      canvasRed.width = terminalRed.offsetWidth;
      canvasRed.height = terminalRed.offsetHeight;
      const fontSize = 18;
      const columnWidth = 15;
      columnsRed = Math.floor(canvasRed.width / columnWidth);
      const totalWidth = columnsRed * columnWidth;
      const offsetX = (canvasRed.width - totalWidth) / 2;
      dropsRed = Array(columnsRed).fill(0).map(() => Math.random() * -20);
      xPositionsRed = Array(columnsRed).fill(0).map((_, i) => offsetX + i * columnWidth + columnWidth / 2);
    }
    
    function drawRed() {
      ctxRed.fillStyle = 'rgba(20, 20, 20, 0.1)';
      ctxRed.fillRect(0, 0, canvasRed.width, canvasRed.height);
      
      ctxRed.font = 'bold 18px Courier New';
      ctxRed.fillStyle = '#ff0000';
      
      for (let i = 0; i < dropsRed.length; i++) {
        const char = charsRed[Math.floor(Math.random() * charsRed.length)];
        const x = xPositionsRed[i];
        const y = dropsRed[i] * 38;
        
        ctxRed.fillText(char, x, y);
        
        if (y > canvasRed.height && Math.random() > 0.95) {
        dropsRed[i] = 0;
        const columnWidth = 15;
        const totalWidth = columnsRed * columnWidth;
        const offsetX = (canvasRed.width - totalWidth) / 2;
        xPositionsRed[i] = offsetX + i * columnWidth + columnWidth / 2 + Math.random() * 8 - 4;
        }
        dropsRed[i] += 0.42;
      }
    }
    
    resizeRed();
    window.addEventListener('resize', resizeRed);
    setInterval(drawRed, 90);
  </script>
  
</body>
</html>   